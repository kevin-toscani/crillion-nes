P:0000:temp:; Zero page RAM\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/zp_ram.asm\n;\n; List of zero-page RAM variables. Currently only holds a\n; variable to keep track of button presses, but will contain\n; more variables that should be accessed often or easily by\n; the game at any time, like temporary variables used by\n; subroutines or macros, game status flags, and the like.\n;\n;\n; Reserve ten temporary variables for use in subroutines.
P:000A:temp16:; Reserve a two-byte temporary variable for use with 16-bit\n; operations (like addresses)
P:000C:pointer:; Two-byte variable to store a pointer address
P:000E:buttons_prev:; Variable to store button presses
P:000F:buttons_held
P:0010:buttons_pressed
P:0011:buttons_released
P:0012:soft_ppu_mask:; PPU mask buffer variable, used to store the new value of\n; the PPU mask outside NMI
P:0013:skip_nmi:; Variables to skip NMI handling
P:0014:force_skip_nmi
P:0015:frame_counter:; Counters and seeds
P:0016:random_seed
P:0017:ball_xpos_hi:; Game specific variables\n; Ball variables
P:0018:ball_xpos_lo
P:0019:ball_ypos_hi
P:001A:ball_ypos_lo
P:001B:ball_lives: number of lives left
P:001C:ball_score: decimal score, five bytes (0-9)
P:0022:ball_bonus: decimal bonus points, three bytes (0-9)
P:0025:ball_left:; Ball bounding box, relative to the screen
P:0026:ball_center
P:0027:ball_right
P:0028:ball_top
P:0029:ball_middle
P:002A:ball_bottom
P:002B:ball_update_position:; Update-position check
P:002C:ball_flags:; Ball flags\n; #% c c c v . f n a\n;    | | | | | | | +-- ball is dead (0) or alive (1)\n;    | | | | | | +---- ball is being nudged left (0) or right (1)\n;    | | | | | +------ ball is frozen (not moving)\n;    | | | | +-------- (unused for now)\n;    | | | +---------- ball moves up (0) or down (1)\n;    +-+-+------------ ball color (1-6)
P:002D:screen_mode:; Screen mode\n; #% u . . . . . t t\n;    | | | | | | +-+--------- screen type (00 = intro, 01 = game, 10 = win)\n;    | +-+-+-+-+------------- unused\n;    +----------------------- should the screen update
P:002E:startlevel_pointer:; Start level pointer\n; You can start the game at level 1, 5, 9, 13 or 17.\n; This is the pointer that tells you at which level to start.
P:002F:ppu_buffer_update:; PPU buffer variables
P:0030:ppu_buffer_pointer
P:0031:explosion_pointer:; Pointer to keep track of the number of explosions
P:0032:sprite_ram_pointer:; Sprite RAM pointer to keep track of sprites to update
P:0033:nudge_counter:; Nudge counter
P:0034:current_level:; Current level
P:0035:colliding_tile:; Tile type the ball is currently colliding with
P:0036:ppu_buffer:; Other RAM (must be ENUM'd within)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; ram/misc.asm\n;\n; List of additional, non-zeropage RAM variables. Currently\n; empty, but will hold data like the OAM buffer and other,\n; less-often accessed, global variables.\n;\n;\n; Game specific RAM variables\n; miscellaneous (non-zeropage) ram variables go here\n; PPU buffer (3x16 bytes, as a capped max for NMI)
P:0066:explosion_framecounter:; _framecounter, counts from ANIMATION_SPEED to 0 per slide
P:006A:explosion_currentframe:; _currentframe, keeps track which anim frame we're at
P:006E:explosion_attributes:; _attributes, to distinguish between ball and wall explosion
P:0072:explosion_x:; x- and y-coordinate of the explosion
P:0076:explosion_y
P:007A:explosion_active:; active flag to see if animation is/should be shown
P:007E:tile_type:; screen tile type data\n;  #% b m p d ccC s\n;     | | | | ||| +-- block is solid\n;     | | | | ||+---- block color (CHR offset boolean)\n;     | | | | ++----- block color (subpal 0-3)\n;     | | | +-------- death block\n;     | | +---------- paint block\n;     | +------------ move block\n;     +-------------- color block
P:011E:tile_attributes:; attribute table in ram (for easy updating during gameplay)
P:015E:RESET:; Instantly go to the static bank\n; Reset script\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/reset.asm\n;\n; Basic reset script. Disables rendering, clears memory, moves\n; sprites off screen and (re)initializes the game.\n;\n;\n; Ignore IRQ's
P:015F::; Disable decimal mode
P:0160::; Disable APU frame IRQ
P:0165::; Set up the stack
P:0168::; Disable NMI, rendering, DMC and APU IRQ's
P:0175::; Clear the vBlank flag
P:0178::; Wait for vBlank
P:017B::; Clear memory\n; Move sprites off screen
P:0180::; Clear other memory
P:0196::; Clear next in line
P:0199::; Wait for vBlank
P:019C::; Turn on NMI, set foreground $0000, background $1000
P:01A1::; Reset PPU scroll pointer
P:01A9::; Initialize game\n; game initialization goes here\n; Tell game to load the intro screen
P:01AD::; Set number of lives (5)
P:01B1::; Start at level -1 for now, because [START] increments level number
P:01B5:MainGameLoop:; Main game loop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; game/main.asm\n;\n; The main game loop content.\n;\n;\n; Reset sprite pointer every game loop
P:01B9::; Store previous buttons
P:01BD::; Read controller input
P:01C0::; Get buttons released
P:01C8::; Set buttons pressed
P:01D0::; Load screen?
P:01D6::; Get screen type to load
P:01DB::; Get address to load screen type from
P:01E5::; Load screen
P:01EE::; Don't load screen anymore next loop
P:01F4::; CONCEPT SCRIPTS\n; Upon pressing A, an explosion will happen on screen\n; If A button is pressed, initiate explosion
P:01FD::; Get most recent slot for explosion
P:01FF::; If 0, use max pointer value
P:0203::; Decrease pointer by one
P:0206::; Load explosion data into RAM
P:0213::AND #%11110000
P:0219::AND #%11110000
P:022C::; Set up loop
P:022E::; Check if current animation is active. If not, goto next
P:0236::; Check the explosion framecounter
P:023B::; Framecounter is 0\n; Reset to animation speed
P:0240::; Set next animation frame, and check if we're done yet
P:024A::; If we're done, inactivate current explosion, clean\n; up sprite RAM and go to the next one
P:0261::; Load (x,y) position in temp variables
P:026D::; Load attribute in temp variable
P:0272::; Load current frame into Y-register
P:0275::; Load current frame ROM address from table
P:027F::; Save x-register on stack
P:0281::; Load sprites into sprite RAM
P:0285::; Prepare (x,y) offset for loop
P:0287::; Do not draw empty sprites
P:028B::; Add y-position to sprite ram buffer
P:0291::; Get tile number from frame ROM address, and\n; add it to sprite ram buffer
P:0297::; Add attribute data to sprite ram buffer
P:029D::; Add x-position to sprite ram buffer
P:02A3::; Check if all sprites are done
P:02A8::; Update x value
P:02AF::; Update temp for x,y position
P:02B7::; Row is done; reset x-position
P:02BB::; Update y-position
P:02C2::; Reset row counter
P:02CB::; Retrieve x-register from stack
P:02CD::; Check if all animations have been updated
P:02D5::; Check if we're on the game screen
P:02DE::; We're on the game screen\n; Check if position should be updated (ie. has nmi happened yet)
P:02E5::; Move the ball\n; Check if ball goes up or down
P:02EB::; update the low byte
P:02F2::; update the high byte with carry
P:02F8::; Check bottom bound
P:02FE::; Change ball direction to "up"
P:030F::; update the low byte
P:0316::; update the high byte with carry
P:031C::; Check top bound
P:0320::; Change ball direction to "down"
P:032E::; Check if ball is being nudged
P:0332::; Check if left button is held
P:0338::; update the low byte
P:033F::; update the high byte
P:0345::; Check left bound
P:0349::; Set flag to nudge right
P:034F::; Set nudge timer
P:0356::; Check if right button is held
P:035C::; update the low byte
P:0363::; update the high byte
P:0369::; Check right bound
P:036F::; Set flag to nudge right
P:0375::; Set nudge timer
P:0379::; Check nudge
P:0383::; update the low byte
P:038A::; update the high byte
P:0393::; update the low byte
P:039A::; update the high byte
P:03A0::; Don't update position again until next frame
P:03A2::; Test collision detection\n; Get ball's x-left, x-center, x-right position
P:03B3::; Get ball's y-top, y-middle, y-bottom position
P:03C4::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:03CA::; Check tile at right position
P:03D7:: no need for left check as ball moves right
P:03D9::; Tile is solid; nudge ball and evaluate tile type
P:03E5::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:03EB::; Check tile at right position
P:03FA::; Tile is solid; nudge ball and evaluate tile type
P:0403::JMP +checkTopCollision\n; Check if ball moves up
P:0409::; Check tile at top position
P:0416:: no need for bottom check as ball moves up
P:0418::; Tile is solid; move ball down and evaluate tile type
P:0424::; No movement check needed: since ball is not moving up, it must move down\n; Check tile at bottom position
P:0433::; Tile is solid; move ball up and evaluate tile type
P:043C::JMP +doneCheckingCollision\n; Add to sprite buffer
P:0458::; Upon pressing START, (next level) design will be drawn\n; If START button is pressed
P:045E::; Load the next level
P:046E::; Sprite clean-up
P:047B:sub_GetRandomNumber:; Subroutines\n; RNG\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/GetRandomNumber.asm\n;\n; Simple and fast random number generator by White Flame.\n;\n; Set random_seed to an arbitrary number to randomize between\n; gaming sessions, for instance using the frame counter upon\n; pressing START on the intro screen.\n;\n;     ;; IF START PRESSED:\n;     LDA frame_counter\n;     STA random_seed\n;\n; Source:\n; codebase64.org/doku.php?id=base:small_fast_8-bit_prng\n;\n;\n; Force EOR if random_seed is zero
P:047F::; Shift left, and EOR if the high bit is set
P:0489:sub_ReadController:; Read controller input\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/ReadController.asm\n;\n; Subroutine that polls the controller and stores the input\n; buttons in a variable. This version only handles controller\n; 1. Expects "buttons" variable to be declared in RAM.\n;\n;\n; Set strobe bit
P:048E::; Set up ring counter
P:0490::; Clear strobe bit
P:0494::; Loop through button presses
P:049A::; Check if ring counter is done
P:049C::; Return from subroutine
P:049D:sub_WaitForVBlank:; vBlank wait\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/WaitForVBlank.asm\n;\n; Subroutine that essentially pauses script execution until\n; vBlank happens.\n;\n;
P:04A3:sub_ClearScreen:; Game specific subroutines\n; additional game-specific subroutines go here\n; Subroutine to clear the screen\n; If it's a game screen, add noise\n; Check of game screen or not
P:04AF::; Set start writing address at tile (0,0) - or PPU address $2000
P:04BC::; Set up tile to draw and loop
P:04C0::; Write empty tile or noise (#$00) and add one to PPU address
P:04C5::; Check if we should draw noise next. Noise is drawn if:\n; - Screen mode is game screen\n; - Y between #$06 and #$19 (inclusive)\n; - X between #$02 and #$1D (inclusive)\n; If not a game screen, or Y exceeds row $17, skip further check
P:04C9::; If Y < $6, skip the check
P:04CD::; If X < $1, skip the check
P:04D1::; If X >= $1D, skip the check. If it IS $1D, set temp = 0
P:04DB::; Load a random noise tile (tiles $68-$6F in CHR ROM)
P:04E5::; Check if a row has been done. If not, draw the next
P:04EA::; Go to the next row (if any left)
P:04ED::; If Y is 1A, skip noise tile check until done drawing
P:04F9::; Clear attribute table
P:050E:sub_ColorizeBall:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n;  Subroutine: ColorizeBall\n;\n;  Applies the color set through ball_flags to the ball sprite.\n;\n;\n; Get color from ball_flags
P:0514::; Add new light color of ball to PPU palette
P:0524::; Add new dark color of ball to PPU palette
P:052F:sub_ColorsMatch:; Subroutine to check if ball color matches colliding tile color\n; Save tile color in temp variable
P:0535::; Get ball color
P:053D::; Compare with tile color
P:0540:sub_ConvertXYToTileType:; Subroutine to convert the ball's position to a tile type\n; - Expects temp to be y-position of ball within game area\n; - Expects temp+1 to be x-position of ball within game area\n; - Puts result in accumulator and zp variable\n; - Corrupts X-register
P:0558:sub_DisableRendering:; Force NMI skip, disable rendering
P:056C:sub_EnableRendering:; Enable rendering
P:0586:sub_drawIntroScreenLogoTile
P:0599:sub_EvaluateTileType:; Subroutine to evaluate the colliding tile type and take its\n; corresponding action (move block, kill player, ...)\n; - Expects X-register to be the ADDR_SCREENTILERAM offset\n; - Uses zp variable colliding_tile\n; Check if collided tile is a color block
P:059F::; It's a color block. Check if the colors match
P:05A4::; Colors don't match - return
P:05A5::; Colors match. Destroy color block\n; - Add the tiles that need updating to ppu buffer\n; - Load destruction animation on tile\n; - Write #$00 in tile type ram (makes not-solid)\n; - Update attribute table accordingly through ppu buffer\n; - If there are no color blocks left:\n;   - Freeze ball\n;   - Initiate level-win state\n; (@TODO)
P:05A6::; Check if collided tile is a paint block
P:05AC::; It's a paint block. Update ball color (@TODO)\n        ;; Save x-register\n        TXA\n        PHA\n\n        ;; Get tile color\n        LDA colliding_tile\n        AND #%00001110\n        ASL\n        ASL\n        ASL\n        ASL\n        STA temp\n\n        ;; Apply tile color to ball\n        LDA ball_flags\n        AND #%00011111\n        ORA temp\n        STA ball_flags\n        JSR sub_ColorizeBall\n\n        ;; Restore x-register\n        PLA\n        TAX\n; Return
P:05AD::; Check if collided tile is a death block
P:05B3::; It is a death block. Kill player and return (@TODO)\n        LDA ball_flags\n        ORA #%00000101\n        STA ball_flags
P:05B4::; Check if collided tile is a move block
P:05BA::; It is a move block. Check if colors match
P:05BF::; Colors don't match - return
P:05C0::; Colors match.\n; - Check if next tile is a solid\n; - If not, move the tile:\n;   - Add the tiles that need updating to ppu buffer\n;   - Add move tile sprite over the original tile\n;   - Initiate moving the sprite that way for 16px\n;   - Write #$00 in tile type ram (makes not-solid)\n;   - Update attribute table accordingly through ppu buffer\n; - After moving the sprite, in a different routine:\n;   - Add move tile data on the new tile location\n;   - Write the original tile type data on new position in ram\n;   - Destroy sprite\n;   - Update attribute table accordingly through ppu buffer\n; (@TODO)
P:05C1::; Return
P:05C2:sub_JumpToPointer
P:05C5:sub_LoadGameScreen:RTS must be handled by the routine (pointer) jumps to\n; Clear the screen
P:05C8::; Clear collision and attribute data
P:05D1::; Get pointer from current level
P:05DD::; Set up the loop
P:05DF::; Load (x,y) of current set of tiles
P:05E1::; Check if level is done; if so, skip the loop
P:05E8::; Store (x,y) and number of tiles and tile data in temp variable
P:05EF::; Convert (x,y) to PPU address\n; temp+2 = PPU_hi = $20 + _y/4_ + carry from temp+3
P:05F9::; temp+3 = PPU_lo = 2*x + $40*(y%4) + $C2
P:0612::; Add carry to temp+2
P:0618::; Convert tile data to loop count and tile type\n; temp+4 = color
P:061E::; If color = 7, this is a wall
P:0622::; temp+7 = first or second set in CHR (add 5 to offset)
P:062A::; temp+5 = tile type
P:0634::; It's a wall! Set CHR offset to 0, and tile type to 4.
P:063C::; X = tile offset
P:0640::; temp+6 = number of tiles
P:064B::; Translate (x,y) to (y,x) for tile RAM
P:065D::; Set up loop
P:0661::; Write PPU address
P:066E::; Write first and second tile
P:067A::; Update PPU address
P:068A::; Write third and fourth tile
P:0696::; Push x-register to stack
P:0698::; Update tile RAM (aka collision table)
P:06A7::; Check if shade 1 should be drawn
P:06B2::; Check if shade 2 should be drawn
P:06D8::; Check if shade 3 should be drawn
P:06EF::; Restore x-register from stack
P:06F1::; Reset pointer for next tile
P:06FE::; Draw next metatile in this loop (if any left)
P:0701::; Is it a row or a column?
P:0705::; It is a column: move pointer down (+$40)
P:0712::; Add 16 to temp (as a tile RAM pointer)
P:071C::; It is a row: move pointer right (+$02)
P:0723::; Add 1 to temp (as a tile RAM pointer)
P:0725::; Next tile in the row/column
P:0728::; Go to the next set of tiles
P:072E::; Level loading is done\n; Top game bound: set PPU_ADDR offset and draw 28 tiles
P:073D::; Bottom game bound: set PPU_ADDR offset and draw 28 tiles
P:074C::; Left & right game bounds\n; Set PPU_ADDR and store in temp variables
P:075A::; Set vertical bound tile and set up loop
P:075E::; Show left tile
P:0761::; Set PPU_ADDR to right bound by adding 29 (tiles) to low byte
P:0770::; Show right tile
P:0773::; Check if we're done yet
P:0776::; Not done yet: add 3 to low byte for next left bound
P:077D::; Apply carry to high byte
P:0783::; Store next PPU_ADDR to draw at
P:078E::; Draw the corners of the playing field
P:07CA::; Draw the hud labels
P:07E1::; Draw the current score
P:07FA::; Draw the level number\n; (with primitive HEX>DEC)
P:0839::; Draw lives (presumes lives to be capped at 9)
P:0849::; Set and draw bonus
P:086C::; Set attribute data to RAM\n; Byte 0-7 of attribute ram should be #%10100000
P:0878::; Byte 8-55 of attribute ram are filled with game subpal data\n; Reset current attribute value
P:087C::; Get first metatile in tile ram based on attribute index\n; metatile = (attr-8)*2 +(16*(attr-8)/8))
P:0880:: attr - 8 (temp1)
P:0882:: * 2
P:0883:: temp = temp1 * 2
P:0885:: temp1
P:0887:: rounded down to 8's
P:0889:: * 2
P:088B:: + temp1 * 2
P:088D:: first metatile
P:088F::; Store first metatile in y-register
P:0890::; If X MOD 8 == 7, don't apply bottom right metatile
P:0897::; If X >= $30, don't apply bottom right metatile
P:089B::; Add metatile1 subpalette to attribute value
P:08A2::; Apply second metatile
P:08A3::; If X MOD 8 == 0, don't apply bottom left metatile
P:08A8::; If X >= $30, don't apply bottom left metatile
P:08AC::; Add metatile2 subpalette to attribute value
P:08BE::; Apply third metatile
P:08C3::; If X MOD 8 == 7, don't apply top right metatile
P:08CA::; If X < $10, don't apply top right metatile
P:08CF::; Add metatile3 subpalette to attribute value
P:08E1::; Apply fourth metatile
P:08E2::; If X MOD 8 == 0, don't apply top left metatile
P:08E7::; If X < $10, don't apply top left metatile
P:08EC::; Add metatile4 subpalette to attribute value
P:08FD::; Check the next attribute, if any left
P:0905::; Stream attribute RAM to PPU
P:091F::; Set initial ball position
P:093D::; Set initial ball color and direction
P:0947::; Return
P:0948:sub_Draw28HorizontalTiles:; Subroutine: draw 28 tiles in a row
P:0951:sub_LoadIntroScreen:; Load intro palette
P:096B::; Put ball in the middle
P:0971::; Clear the screen
P:0974::; Set up intro screen draw loop
P:0976::; Get current byte from intro screen data
P:0979::; If current byte is #$3F, we're done drawing.
P:0980::; If highest bits are %11, draw a plain tile
P:0987::; If highest bits are %01, set the PPU address\n; If not, draw two logo tiles
P:098E::; Get bits 0-2 and store in a temp variable
P:0995::; Get bits 3-5, shift over to get a value from 0-7
P:099D::; Draw the tile that corresponds with that value
P:09A1::; Do the same for the value stored in temp
P:09A6::; Next byte please
P:09AA::; Just draw the tile value on screen
P:09B0::; Next byte please
P:09B4::; Reset the PPU latch
P:09B7::; Sanitize and write the high byte of the PPU address
P:09BF::; Write the low byte of the PPU address
P:09C6::; PPU has been set up to draw tiles at the correct spot now.\n; Next byte please.
P:09CA::; To color the 1.LEVEL: line green, we need to update two\n; values in the PPU attribute data.
P:09E0:sub_LoadWinScreen
P:09E1:sub_WriteByteToPPUBuffer:; Prevent updating until full 3-byte buffer is filled,\n; so that graphics won't glitch out if NMI happens during\n; updating the buffer
P:09E5::; Check if buffer full; if so, wait a frame and force update
P:09F0::; Add ppu_addr high byte to buffer
P:09F5::; Add ppu_addr low byte to buffer
P:09FB::; Add ppu_data to buffer
P:0A01::; Update buffer pointer
P:0A04::; Tell NMI to update next round
P:0A06::; Return
P:0A07:tbl_IntroScreenPalette:; LUTs\n; Intro screen palette
P:0A27:tbl_IntroScreenLogoChr:; Intro: mapping logo index to chr tile
P:0A2F:tbl_IntroScreenData:; Intro screen data\n; Set PPU address $20AC and draw
P:0A39::; Set PPU address $20CF and draw
P:0A3D::; Set PPU address $2122 and draw
P:0A59::; Set PPU address $2147 and draw
P:0A72::; Set PPU address $218B and draw
P:0A7F::; Set PPU address $21E6 and draw
P:0A94::; Set PPU address $222D and draw
P:0A9C::; Set PPU address $2281
P:0A9E::; Draw the Crillion logo
P:0AFD::; End of intro
P:0AFE:explosion_slide0:; test animation table\n; CHR tile-id's per slide of explosion
P:0B07:explosion_slide1
P:0B10:explosion_slide2
P:0B19:explosion_slide3
P:0B22:explosion_slide4
P:0B2B:explosion_anim_hi:; High and low bytes of animation slides
P:0B35:explosion_anim_lo
P:0B3F:tbl_BallColorDark:; Ball palette color table (CBRYGM)
P:0B45:tbl_BallColorLight
P:0B4B:tbl_LoadScreenHi:; Screen mode drawing routine addresses
P:0B4E:tbl_LoadScreenLo
P:0B51:lvl_layout_01:; Test level data
P:0B6C:lvl_layout_02
P:0BA1:lvl_layout_03
P:0BD4:lvl_layout_04
P:0C45:lvl_layout_05
P:0C80:lvl_layout_06
P:0D09:lvl_layout_07
P:0D4A:lvl_layout_08
P:0D81:lvl_layout_09
P:0DC4:lvl_layout_10
P:0DF3:lvl_layout_11
P:0E46:lvl_layout_12
P:0E71:lvl_layout_13
P:0EC4:lvl_layout_14
P:0F3B:lvl_layout_15
P:0F6C:lvl_layout_16
P:0FC1:lvl_layout_17
P:1028:lvl_layout_18
P:107D:lvl_layout_19
P:10BC:lvl_layout_20
P:1107:lvl_layout_21
P:1144:lvl_layout_22
P:1171:lvl_layout_23
P:11BC:lvl_layout_24
P:1201:lvl_layout_25
P:1230:tbl_lvl_layout_hi:; Level layout address pointers
P:1249:tbl_lvl_layout_lo
P:1262:tbl_lvl_ball_startpos:; Ball start position (#$YX)
P:127B:tbl_lvl_ball_init:; Ball start direction, color and tile score\n; #% ccc v tttt\n;    ||| | ++++-- tile score\n;    ||| +------- vertical direction, up (0) or down\n;    +++--------- color (CBRYGM)
P:1294:tbl_Times64:; Helper table to multiply values by 64
P:1298:tbl_GametileTopLeft:; Metatile ID to CHR data mapper
P:12A2:tbl_GametileTopRight
P:12AC:tbl_GametileBottomLeft
P:12B6:tbl_GametileBottomRight
P:12C0:tbl_GameTileRamByte:; Metatile ID to RAM byte data mapper
P:12C5:tbl_HudText:; HUD text data
P:12E1:NMI:; NMI handler\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/nmi.asm\n;\n; Non-maskable interrupt script. This script is being executed\n; when vBlank hits.\n;\n;\n; Preserve accumulator through stack
P:12E2::; Should NMI be skipped?
P:12E9::; When in NMI, skip additional NMI requests
P:12ED::; Preserve X, Y, and PC through stack
P:12F2::; Check forced NMI skip
P:12F9::; Update PPU mask\nLDA #$00\nSTA PPU_CTRL
P:12FE::; Additional PPU updates go here\n; Check if ppu_buffer needs updating
P:1305::; Reset ppu control register and mask
P:130D::; Set up loop\n; Reset hi/lo latch
P:1310::; Write ppu_buffer hi and lo addresss to PPU_ADDR
P:131D::; Write ppu_buffer data to PPU_ADDR
P:1324::; Check if updating is done (eg. X is at pointer)
P:132C::; Reset ppu buffer update and pointer
P:1332::; Reset scrolling position
P:1338::; Restore ppu control register and mask
P:1344::; Continue other NMI stuff\n; Reset sprite RAM, draw sprites
P:1365::; This is what happens when we forced nmi skip\n; Increase frame counters
P:1367::; reset ball_update_position
P:136B::; Don't skip next NMI request
P:136F::; Restore X, Y and PC from stack
P:1374::; Restore accumulator from stack
P:1375::; Return
P:1376:IRQ:; IRQ handler (empty)
R:0000:ADDR_CHRROM
R:0000:ADDR_ZEROPAGE
R:0000:BALL_ATTR
R:0000:BALL_LEFT
R:0000:BALL_TOP
R:0000:IS_INTRO_SCREEN
R:0000:_SPACE
R:0001:BALL_IS_DEAD
R:0001:BALL_TILE_CHR
R:0001:BUTTON_RIGHT
R:0001:IS_GAME_SCREEN
R:0001:KILL_BALL
R:0001:TILE_IS_SOLID
R:0001:_0
R:0002:BALL_SPEED_HI
R:0002:BUTTON_LEFT
R:0002:IS_WIN_SCREEN
R:0002:NUDGE_BALL_RIGHT
R:0002:_1
R:0003:CHECK_SCREEN_MODE
R:0003:NUDGE_FRAMES
R:0003:SLIDE_WIDTH
R:0003:_2
R:0004:ANIMATION_SPEED
R:0004:BALL_HALF_SIZE
R:0004:BALL_IS_FROZEN
R:0004:BUTTON_DOWN
R:0004:FREEZE_BALL
R:0004:MAX_ANIMATIONS
R:0004:_3
R:0005:_4
R:0006:_5
R:0007:_6
R:0008:BALL_HEIGHT
R:0008:BALL_WIDTH
R:0008:BUTTON_UP
R:0008:_7
R:0009:SLIDE_SIZE
R:0009:_8
R:000A:ANIM_SLIDES
R:000A:_9
R:000B:_A
R:000C:_B
R:000D:_C
R:000E:_D
R:000F:_E
R:0010:BALL_MOVES_DOWN
R:0010:BOUND_LEFT
R:0010:BUTTON_START
R:0010:IS_PAINT_BLOCK
R:0010:MOVE_BALL_DOWN
R:0010:_F
R:0011:_G
R:0012:_H
R:0013:_I
R:0014:_J
R:0015:_K
R:0016:_L
R:0017:_M
R:0018:_N
R:0019:_O
R:001A:_P
R:001B:_Q
R:001C:_R
R:001D:_S
R:001E:_T
R:001F:_U
R:0020:BUTTON_SELECT
R:0020:IS_DEATH_BLOCK
R:0020:_V
R:0021:_W
R:0022:_X
R:0023:_Y
R:0024:_Z
R:0025:_COMMA
R:0026:_DOT
R:0027:_COLON
R:0028:_COPY
R:0030:BALL_SPEED_LO
R:0030:BOUND_TOP
R:0040:BUTTON_B
R:0040:IS_MOVE_BLOCK
R:0080:BUTTON_A
R:0080:IS_COLOR_BLOCK
R:0080:LOAD_INTRO_SCREEN
R:0081:LOAD_GAME_SCREEN
R:0082:LOAD_WIN_SCREEN
R:00C8:BOUND_BOTTOM
R:00D0:BALL_TOP_WGA
R:00E8:BOUND_RIGHT
R:00EF:MOVE_BALL_UP
R:00F0:BALL_LEFT_WGA
R:00FB:UNFREEZE_BALL
R:00FD:NUDGE_BALL_LEFT
R:00FE:REVIVE_BALL
R:00FF:LEVEL_END
R:0100:ADDR_SOUNDRAM
R:0200:ADDR_SPRITERAM
R:0300:ADDR_OTHERRAM
R:0400:ADDR_SCREENTILERAM
G:2000:PPU_CTRL
G:2001:PPU_MASK
G:2002:PPU_STATUS
G:2003:OAM_ADDR
G:2004:OAM_DATA
G:2005:PPU_SCROLL
G:2006:PPU_ADDR
G:2007:PPU_DATA
G:4010:APU_CTRL
G:4014:OAM_DMA
G:4015:APU_STATUS
G:4016:JOYPAD_1
G:4017:APU_FC
G:4017:JOYPAD_2
G:8000:ADDR_STARTBANK
G:C000:ADDR_ENDBANK
G:FFFA:ADDR_VECTORS
