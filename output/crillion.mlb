P:0000:temp:; Zero page RAM\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/zp_ram.asm\n;\n; List of zero-page RAM variables. Currently only holds a\n; variable to keep track of button presses, but will contain\n; more variables that should be accessed often or easily by\n; the game at any time, like temporary variables used by\n; subroutines or macros, game status flags, and the like.\n;\n;\n; Reserve ten temporary variables for use in subroutines.
P:000A:temp16:; Reserve a two-byte temporary variable for use with 16-bit\n; operations (like addresses)
P:000C:pointer:; Two-byte variable to store a pointer address
P:000E:buttons_prev:; Variable to store button presses
P:000F:buttons_held
P:0010:buttons_pressed
P:0011:buttons_released
P:0012:soft_ppu_mask:; PPU mask buffer variable, used to store the new value of\n; the PPU mask outside NMI
P:0013:skip_nmi:; Variables to skip NMI handling
P:0014:force_skip_nmi
P:0015:frame_counter:; Counters and seeds
P:0016:random_seed
P:0017:ball_xpos_hi:; Game specific variables\n; Ball variables
P:0018:ball_xpos_lo
P:0019:ball_ypos_hi
P:001A:ball_ypos_lo
P:001B:ball_lives: number of lives left
P:001C:ball_score: decimal score, five bytes (0-9)
P:0022:ball_bonus: decimal bonus points, three bytes (0-9)
P:0025:ball_left:; Ball bounding box, relative to the screen
P:0026:ball_center
P:0027:ball_right
P:0028:ball_top
P:0029:ball_middle
P:002A:ball_bottom
P:002B:ball_update_position:; Update-position check
P:002C:ball_flags:; Ball flags\n; #% c c c v . f n a\n;    | | | | | | | +-- ball is dead (0) or alive (1)\n;    | | | | | | +---- ball is being nudged left (0) or right (1)\n;    | | | | | +------ ball is frozen (not moving)\n;    | | | | +-------- (unused for now)\n;    | | | +---------- ball moves up (0) or down (1)\n;    +-+-+------------ ball color (1-6)
P:002D:screen_mode:; Screen mode\n; #% u . . . . . t t\n;    | | | | | | +-+--------- screen type (00 = intro, 01 = game, 10 = win)\n;    | +-+-+-+-+------------- unused\n;    +----------------------- should the screen update
P:002E:startlevel_pointer:; Start level pointer\n; You can start the game at level 1, 5, 9, 13 or 17.\n; This is the pointer that tells you at which level to start.
P:002F:ppu_buffer_update:; PPU buffer variables
P:0030:ppu_buffer_pointer
P:0031:explosion_pointer:; Pointer to keep track of the number of explosions
P:0032:sprite_ram_pointer:; Sprite RAM pointer to keep track of sprites to update
P:0033:nudge_counter:; Nudge counter
P:0034:current_level:; Current level
P:0035:colliding_tile:; Tile type the ball is currently colliding with
P:0036:ppu_buffer:; Other RAM (must be ENUM'd within)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; ram/misc.asm\n;\n; List of additional, non-zeropage RAM variables. Currently\n; empty, but will hold data like the OAM buffer and other,\n; less-often accessed, global variables.\n;\n;\n; Game specific RAM variables\n; miscellaneous (non-zeropage) ram variables go here\n; PPU buffer (3x16 bytes, as a capped max for NMI)
P:0066:explosion_framecounter:; _framecounter, counts from ANIMATION_SPEED to 0 per slide
P:006A:explosion_currentframe:; _currentframe, keeps track which anim frame we're at
P:006E:explosion_attributes:; _attributes, to distinguish between ball and wall explosion
P:0072:explosion_x:; x- and y-coordinate of the explosion
P:0076:explosion_y
P:007A:explosion_active:; active flag to see if animation is/should be shown
P:007E:tile_type:; screen tile type data\n;  #% b m p d ccC s\n;     | | | | ||| +-- block is solid\n;     | | | | ||+---- block color (CHR offset boolean)\n;     | | | | ++----- block color (subpal 0-3)\n;     | | | +-------- death block\n;     | | +---------- paint block\n;     | +------------ move block\n;     +-------------- color block
P:011E:tile_attributes:; attribute table in ram (for easy updating during gameplay)
P:015E:RESET:; Instantly go to the static bank\n; Reset script\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/reset.asm\n;\n; Basic reset script. Disables rendering, clears memory, moves\n; sprites off screen and (re)initializes the game.\n;\n;\n; Ignore IRQ's
P:015F::; Disable decimal mode
P:0160::; Disable APU frame IRQ
P:0165::; Set up the stack
P:0168::; Disable NMI, rendering, DMC and APU IRQ's
P:0175::; Clear the vBlank flag
P:0178::; Wait for vBlank
P:017B::; Clear memory\n; Move sprites off screen
P:0180::; Clear other memory
P:0196::; Clear next in line
P:0199::; Wait for vBlank
P:019C::; Turn on NMI, set foreground $0000, background $1000
P:01A1::; Reset PPU scroll pointer
P:01A9::; Initialize game\n; game initialization goes here\n; Tell game to load the intro screen
P:01AD::; Set number of lives (5)
P:01B1::; Start at level -1 for now, because [START] increments level number
P:01B5:MainGameLoop:; Main game loop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; game/main.asm\n;\n; The main game loop content.\n;\n;\n; Reset sprite pointer every game loop
P:01B9::; Store previous buttons
P:01BD::; Read controller input
P:01C0::; Get buttons released
P:01C8::; Set buttons pressed
P:01D0::; Load screen?
P:01D6::; Get screen type to load
P:01DB::; Get address to load screen type from
P:01E5::; Load screen
P:01EE::; Don't load screen anymore next loop
P:01F4::; Check if we're on the game screen
P:01FD::; Load sprite 0 in place
P:0215::; We're on the game screen\n; Check if position should be updated (ie. has nmi happened yet)
P:021C::; Move the ball\n; Check if ball goes up or down
P:0222::; update the low byte
P:0229::; update the high byte with carry
P:022F::; Check bottom bound
P:0235::; Change ball direction to "up"
P:0246::; update the low byte
P:024D::; update the high byte with carry
P:0253::; Check top bound
P:0257::; Change ball direction to "down"
P:0265::; Check if ball is being nudged
P:0269::; Check if left button is held
P:026F::; update the low byte
P:0276::; update the high byte
P:027C::; Check left bound
P:0280::; Set flag to nudge right and set nudge counter
P:028A::; Check if right button is held
P:0290::; update the low byte
P:0297::; update the high byte
P:029D::; Check right bound
P:02A3::; Set flag to nudge left and set nudge timer
P:02AA::; Check nudge
P:02B4::; update the low byte
P:02BB::; update the high byte
P:02C4::; update the low byte
P:02CB::; update the high byte
P:02D1::; Don't update position again until next frame
P:02D3::; Do collision detection\n; Get ball's x-left, x-center, x-right position
P:02E4::; Get ball's y-top, y-middle, y-bottom position
P:02F5::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:02FB::; Check tile at right position
P:0308:: no need for left check as ball moves right
P:030A::; Tile is solid; nudge ball and evaluate tile type
P:0317::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:031D::; Check tile at right position
P:032C::; Tile is solid; nudge ball and evaluate tile type
P:0336::; Check if ball moves up
P:033C::; Check tile at top position
P:0349:: no need for bottom check as ball moves up
P:034B::; Tile is solid; move ball down and evaluate tile type
P:0357::; No movement check needed: since ball is not moving up, it must move down\n; Check tile at bottom position
P:0366::; Tile is solid; move ball up and evaluate tile type
P:036F::; Testinging timed PPU scroll concept\n; Timed updates (test)\n; If B button is pressed
P:0375::; Set up loop fading
P:037D::; Wait for NMI to pass
P:0380::; Now wait for No-sprite 0
P:0387::; Now wait for Sprite 0
P:038E::; Setup tile row loop
P:0390::; Disable drawing
P:0397::; Set up scanline loop
P:039D::; Restore drawing
P:03A7::; Waste 12 frames\n+5
P:03A9::+5
P:03AB::+2
P:03AD::; Waste about 100 frames\n  3 down, 97 to go
P:03AF::  5 down, 95 to go
P:03B2::  5+3L down,  95-3L to go
P:03B4::  5+5L down,  95-5L to go
P:03B5::  4+8L down,  96-8L to go
P:03B7::  7+8L down, 93-8L to go
P:03B9::  9+8L down, 91-8L to go
P:03BA:: 12+8L down, 88-8L to go
P:03D0::; Turn off the screen
P:03D7::; Load the next level
P:03E7::; Add to sprite buffer
P:0406::; Upon pressing START, (next level) design will be drawn\n; If START button is pressed
P:040C::; Load the next level
P:041C::; Upon pressing A, an explosion will happen on screen\n; If A button is pressed, initiate explosion
P:0425::; Get most recent slot for explosion
P:0427::; If 0, use max pointer value
P:042B::; Decrease pointer by one
P:042E::; Load explosion data into RAM
P:043B::AND #%11110000
P:0441::AND #%11110000
P:0454::; Set up loop
P:0456::; Check if current animation is active. If not, goto next
P:045E::; Check the explosion framecounter
P:0463::; Framecounter is 0\n; Reset to animation speed
P:0468::; Set next animation frame, and check if we're done yet
P:0472::; If we're done, inactivate current explosion, clean\n; up sprite RAM and go to the next one
P:0489::; Load (x,y) position in temp variables
P:0495::; Load attribute in temp variable
P:049A::; Load current frame into Y-register
P:049D::; Load current frame ROM address from table
P:04A7::; Save x-register on stack
P:04A9::; Load sprites into sprite RAM
P:04AD::; Prepare (x,y) offset for loop
P:04AF::; Do not draw empty sprites
P:04B3::; Add y-position to sprite ram buffer
P:04B9::; Get tile number from frame ROM address, and\n; add it to sprite ram buffer
P:04BF::; Add attribute data to sprite ram buffer
P:04C5::; Add x-position to sprite ram buffer
P:04CB::; Check if all sprites are done
P:04D0::; Update x value
P:04D7::; Update temp for x,y position
P:04DF::; Row is done; reset x-position
P:04E3::; Update y-position
P:04EA::; Reset row counter
P:04F3::; Retrieve x-register from stack
P:04F5::; Check if all animations have been updated
P:04FD::; Sprite clean-up
P:050A:sub_GetRandomNumber:; Subroutines\n; RNG\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/GetRandomNumber.asm\n;\n; Simple and fast random number generator by White Flame.\n;\n; Set random_seed to an arbitrary number to randomize between\n; gaming sessions, for instance using the frame counter upon\n; pressing START on the intro screen.\n;\n;     ;; IF START PRESSED:\n;     LDA frame_counter\n;     STA random_seed\n;\n; Source:\n; codebase64.org/doku.php?id=base:small_fast_8-bit_prng\n;\n;\n; Force EOR if random_seed is zero
P:050E::; Shift left, and EOR if the high bit is set
P:0518:sub_ReadController:; Read controller input\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/ReadController.asm\n;\n; Subroutine that polls the controller and stores the input\n; buttons in a variable. This version only handles controller\n; 1. Expects "buttons" variable to be declared in RAM.\n;\n;\n; Set strobe bit
P:051D::; Set up ring counter
P:051F::; Clear strobe bit
P:0523::; Loop through button presses
P:0529::; Check if ring counter is done
P:052B::; Return from subroutine
P:052C:sub_WaitForVBlank:; vBlank wait\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/WaitForVBlank.asm\n;\n; Subroutine that essentially pauses script execution until\n; vBlank happens.\n;\n;
P:0532:sub_ClearScreen:; Game specific subroutines\n; additional game-specific subroutines go here\n; Subroutine to clear the screen\n; If it's a game screen, add noise\n; Check of game screen or not
P:053E::; Set start writing address at tile (0,0) - or PPU address $2000
P:054B::; Set up tile to draw and loop
P:054F::; Write empty tile or noise (#$00) and add one to PPU address
P:0554::; Check if we should draw noise next. Noise is drawn if:\n; - Screen mode is game screen\n; - Y between #$06 and #$19 (inclusive)\n; - X between #$02 and #$1D (inclusive)\n; If not a game screen, or Y exceeds row $17, skip further check
P:0558::; If Y < $6, skip the check
P:055C::; If X < $1, skip the check
P:0560::; If X >= $1D, skip the check. If it IS $1D, set temp = 0
P:056A::; Load a random noise tile (tiles $68-$6F in CHR ROM)
P:0574::; Check if a row has been done. If not, draw the next
P:0579::; Go to the next row (if any left)
P:057C::; If Y is 1A, skip noise tile check until done drawing
P:0588::; Clear attribute table
P:059D:sub_ColorizeBall:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n;  Subroutine: ColorizeBall\n;\n;  Applies the color set through ball_flags to the ball sprite.\n;\n;\n; Get color from ball_flags
P:05A3::; Add new light color of ball to PPU palette
P:05B3::; Add new dark color of ball to PPU palette
P:05BE:sub_ColorsMatch:; Subroutine to check if ball color matches colliding tile color\n; Save tile color in temp variable
P:05C4::; Get ball color
P:05CC::; Compare with tile color
P:05CF:sub_ConvertXYToTileType:; Subroutine to convert the ball's position to a tile type\n; - Expects temp to be y-position of ball within game area\n; - Expects temp+1 to be x-position of ball within game area\n; - Puts result in accumulator and zp variable\n; - Corrupts X-register
P:05E7:sub_DisableRendering:; Force NMI skip, disable rendering
P:05FB:sub_EnableRendering:; Enable rendering
P:0615:sub_drawIntroScreenLogoTile
P:0628:sub_EvaluateTileType:; Subroutine to evaluate the colliding tile type and take its\n; corresponding action (move block, kill player, ...)\n; - Expects X-register to be the ADDR_SCREENTILERAM offset\n; - Uses zp variable colliding_tile\n; Check if collided tile is a color block
P:062E::; It's a color block. Check if the colors match
P:0633::; Colors don't match - return
P:0634::; Colors match. Destroy color block\n; - Add the tiles that need updating to ppu buffer\n; - Load destruction animation on tile\n; - Write #$00 in tile type ram (makes not-solid)\n; - Update attribute table accordingly through ppu buffer\n; - If there are no color blocks left:\n;   - Freeze ball\n;   - Initiate level-win state\n; (@TODO)
P:0635::; Check if collided tile is a paint block
P:063B::; It's a paint block. Update ball color\n; Save x-register
P:063D::; Get tile color
P:0647::; Apply tile color to ball
P:0652::; Restore x-register
P:0654::; Return
P:0655::; Check if collided tile is a death block
P:065B::; It is a death block. Kill player and return (@TODO)\n        LDA ball_flags\n        ORA #%00000101\n        STA ball_flags
P:065C::; Check if collided tile is a move block
P:0662::; It is a move block. Check if colors match
P:0667::; Colors don't match - return
P:0668::; Colors match.\n; - Check if next tile is a solid\n; - If not, move the tile:\n;   - Add the tiles that need updating to ppu buffer\n;   - Add move tile sprite over the original tile\n;   - Initiate moving the sprite that way for 16px\n;   - Write #$00 in tile type ram (makes not-solid)\n;   - Update attribute table accordingly through ppu buffer\n; - After moving the sprite, in a different routine:\n;   - Add move tile data on the new tile location\n;   - Write the original tile type data on new position in ram\n;   - Destroy sprite\n;   - Update attribute table accordingly through ppu buffer\n; (@TODO)
P:0669::; Return
P:066A:sub_InitiateNudge
P:0671:sub_JumpToPointer
P:0674:sub_LoadGameScreen:RTS must be handled by the routine (pointer) jumps to\n; Clear the screen
P:0677::; Clear collision and attribute data
P:0680::; Get pointer from current level
P:068C::; Set up the loop
P:068E::; Load (x,y) of current set of tiles
P:0690::; Check if level is done; if so, skip the loop
P:0697::; Store (x,y) and number of tiles and tile data in temp variable
P:069E::; Convert (x,y) to PPU address\n; temp+2 = PPU_hi = $20 + _y/4_ + carry from temp+3
P:06A8::; temp+3 = PPU_lo = 2*x + $40*(y%4) + $C2
P:06C1::; Add carry to temp+2
P:06C7::; Convert tile data to loop count and tile type\n; temp+4 = color
P:06CD::; If color = 7, this is a wall
P:06D1::; temp+7 = first or second set in CHR (add 5 to offset)
P:06D9::; temp+5 = tile type
P:06E3::; It's a wall! Set CHR offset to 0, and tile type to 4.
P:06EB::; X = tile offset
P:06EF::; temp+6 = number of tiles
P:06FA::; Translate (x,y) to (y,x) for tile RAM
P:070C::; Set up loop
P:0710::; Write PPU address
P:071D::; Write first and second tile
P:0729::; Update PPU address
P:0739::; Write third and fourth tile
P:0745::; Push x-register to stack
P:0747::; Update tile RAM (aka collision table)
P:0756::; Check if shade 1 should be drawn
P:0761::; Check if shade 2 should be drawn
P:0787::; Check if shade 3 should be drawn
P:079E::; Restore x-register from stack
P:07A0::; Reset pointer for next tile
P:07AD::; Draw next metatile in this loop (if any left)
P:07B0::; Is it a row or a column?
P:07B4::; It is a column: move pointer down (+$40)
P:07C1::; Add 16 to temp (as a tile RAM pointer)
P:07CB::; It is a row: move pointer right (+$02)
P:07D2::; Add 1 to temp (as a tile RAM pointer)
P:07D4::; Next tile in the row/column
P:07D7::; Go to the next set of tiles
P:07DD::; Level loading is done\n; Top game bound: set PPU_ADDR offset and draw 28 tiles
P:07EC::; Bottom game bound: set PPU_ADDR offset and draw 28 tiles
P:07FB::; Left & right game bounds\n; Set PPU_ADDR and store in temp variables
P:0809::; Set vertical bound tile and set up loop
P:080D::; Show left tile
P:0810::; Set PPU_ADDR to right bound by adding 29 (tiles) to low byte
P:081F::; Show right tile
P:0822::; Check if we're done yet
P:0825::; Not done yet: add 3 to low byte for next left bound
P:082C::; Apply carry to high byte
P:0832::; Store next PPU_ADDR to draw at
P:083D::; Draw the corners of the playing field
P:0879::; Draw the hud labels
P:0890::; Draw the current score
P:08A9::; Draw the level number\n; (with primitive HEX>DEC)
P:08E8::; Draw lives (presumes lives to be capped at 9)
P:08F8::; Set and draw bonus
P:091B::; Set attribute data to RAM\n; Byte 0-7 of attribute ram should be #%10100000
P:0927::; Byte 8-55 of attribute ram are filled with game subpal data\n; Reset current attribute value
P:092B::; Get first metatile in tile ram based on attribute index\n; metatile = (attr-8)*2 +(16*(attr-8)/8))
P:092F:: attr - 8 (temp1)
P:0931:: * 2
P:0932:: temp = temp1 * 2
P:0934:: temp1
P:0936:: rounded down to 8's
P:0938:: * 2
P:093A:: + temp1 * 2
P:093C:: first metatile
P:093E::; Store first metatile in y-register
P:093F::; If X MOD 8 == 7, don't apply bottom right metatile
P:0946::; If X >= $30, don't apply bottom right metatile
P:094A::; Add metatile1 subpalette to attribute value
P:0951::; Apply second metatile
P:0952::; If X MOD 8 == 0, don't apply bottom left metatile
P:0957::; If X >= $30, don't apply bottom left metatile
P:095B::; Add metatile2 subpalette to attribute value
P:096D::; Apply third metatile
P:0972::; If X MOD 8 == 7, don't apply top right metatile
P:0979::; If X < $10, don't apply top right metatile
P:097E::; Add metatile3 subpalette to attribute value
P:0990::; Apply fourth metatile
P:0991::; If X MOD 8 == 0, don't apply top left metatile
P:0996::; If X < $10, don't apply top left metatile
P:099B::; Add metatile4 subpalette to attribute value
P:09AC::; Check the next attribute, if any left
P:09B4::; Stream attribute RAM to PPU
P:09CE::; Set initial ball position
P:09EC::; Set initial ball color and direction
P:09F6::; Return
P:09F7:sub_Draw28HorizontalTiles:; Subroutine: draw 28 tiles in a row
P:0A00:sub_LoadIntroScreen:; Load intro palette
P:0A1A::; Put ball in the middle
P:0A20::; Clear the screen
P:0A23::; Set up intro screen draw loop
P:0A25::; Get current byte from intro screen data
P:0A28::; If current byte is #$3F, we're done drawing.
P:0A2F::; If highest bits are %11, draw a plain tile
P:0A36::; If highest bits are %01, set the PPU address\n; If not, draw two logo tiles
P:0A3D::; Get bits 0-2 and store in a temp variable
P:0A44::; Get bits 3-5, shift over to get a value from 0-7
P:0A4C::; Draw the tile that corresponds with that value
P:0A50::; Do the same for the value stored in temp
P:0A55::; Next byte please
P:0A59::; Just draw the tile value on screen
P:0A5F::; Next byte please
P:0A63::; Reset the PPU latch
P:0A66::; Sanitize and write the high byte of the PPU address
P:0A6E::; Write the low byte of the PPU address
P:0A75::; PPU has been set up to draw tiles at the correct spot now.\n; Next byte please.
P:0A79::; To color the 1.LEVEL: line green, we need to update two\n; values in the PPU attribute data.
P:0A8F:sub_LoadWinScreen
P:0A90:sub_WriteByteToPPUBuffer:; Prevent updating until full 3-byte buffer is filled,\n; so that graphics won't glitch out if NMI happens during\n; updating the buffer
P:0A94::; Check if buffer full; if so, wait a frame and force update
P:0A9F::; Add ppu_addr high byte to buffer
P:0AA4::; Add ppu_addr low byte to buffer
P:0AAA::; Add ppu_data to buffer
P:0AB0::; Update buffer pointer
P:0AB3::; Tell NMI to update next round
P:0AB5::; Return
P:0AB6:tbl_IntroScreenPalette:; LUTs\n; Intro screen palette
P:0AD6:tbl_IntroScreenLogoChr:; Intro: mapping logo index to chr tile
P:0ADE:tbl_IntroScreenData:; Intro screen data\n; Set PPU address $20AC and draw
P:0AE8::; Set PPU address $20CF and draw
P:0AEC::; Set PPU address $2122 and draw
P:0B08::; Set PPU address $2147 and draw
P:0B21::; Set PPU address $218B and draw
P:0B2E::; Set PPU address $21E6 and draw
P:0B43::; Set PPU address $222D and draw
P:0B4B::; Set PPU address $2281
P:0B4D::; Draw the Crillion logo
P:0BAC::; End of intro
P:0BAD:explosion_slide0:; Animation frames table\n; CHR tile-id's per slide of explosion
P:0BB6:explosion_slide1
P:0BBF:explosion_slide2
P:0BC8:explosion_slide3
P:0BD1:explosion_slide4
P:0BDA:explosion_anim_hi:; High and low bytes of animation slides
P:0BE4:explosion_anim_lo
P:0BEE:tbl_BallColorDark:; Ball palette color table (CBRYGM)
P:0BF4:tbl_BallColorLight
P:0BFA:tbl_LoadScreenHi:; Screen mode drawing routine addresses
P:0BFD:tbl_LoadScreenLo
P:0C00:lvl_layout_01:; Level data
P:0C1B:lvl_layout_02
P:0C50:lvl_layout_03
P:0C83:lvl_layout_04
P:0CF4:lvl_layout_05
P:0D2F:lvl_layout_06
P:0DB8:lvl_layout_07
P:0DF9:lvl_layout_08
P:0E30:lvl_layout_09
P:0E73:lvl_layout_10
P:0EA2:lvl_layout_11
P:0EF5:lvl_layout_12
P:0F20:lvl_layout_13
P:0F73:lvl_layout_14
P:0FEA:lvl_layout_15
P:101B:lvl_layout_16
P:1070:lvl_layout_17
P:10D7:lvl_layout_18
P:112C:lvl_layout_19
P:116B:lvl_layout_20
P:11B6:lvl_layout_21
P:11F3:lvl_layout_22
P:1220:lvl_layout_23
P:126B:lvl_layout_24
P:12B0:lvl_layout_25
P:12DF:tbl_lvl_layout_hi:; Level layout address pointers
P:12F8:tbl_lvl_layout_lo
P:1311:tbl_lvl_ball_startpos:; Ball start position (#$YX)
P:132A:tbl_lvl_ball_init:; Ball start direction, color and tile score\n; #% ccc v tttt\n;    ||| | ++++-- tile score\n;    ||| +------- vertical direction, up (0) or down\n;    +++--------- color (CBRYGM)
P:1343:tbl_Times64:; Helper table to multiply values by 64
P:1347:tbl_GametileTopLeft:; Metatile ID to CHR data mapper
P:1351:tbl_GametileTopRight
P:135B:tbl_GametileBottomLeft
P:1365:tbl_GametileBottomRight
P:136F:tbl_GameTileRamByte:; Metatile ID to RAM byte data mapper
P:1374:tbl_HudText:; HUD text data
P:1390:NMI:; NMI handler\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/nmi.asm\n;\n; Non-maskable interrupt script. This script is being executed\n; when vBlank hits.\n;\n;\n; Preserve accumulator through stack
P:1391::; Should NMI be skipped?
P:1398::; When in NMI, skip additional NMI requests
P:139C::; Preserve X, Y, and PC through stack
P:13A1::; Check forced NMI skip
P:13A8::; Update PPU mask\nLDA #$00\nSTA PPU_CTRL
P:13AD::; Additional PPU updates go here\n; Check if ppu_buffer needs updating
P:13B4::; Reset ppu control register and mask
P:13BC::; Set up loop\n; Reset hi/lo latch
P:13BF::; Write ppu_buffer hi and lo addresss to PPU_ADDR
P:13CC::; Write ppu_buffer data to PPU_ADDR
P:13D3::; Check if updating is done (eg. X is at pointer)
P:13DB::; Reset ppu buffer update and pointer
P:13E1::; Reset scrolling position
P:13E7::; Restore ppu control register and mask
P:13F3::; Continue other NMI stuff\n; Reset sprite RAM, draw sprites
P:13FB::; Decrease explosion frame counters
P:140E::; Decrease nudge counter
P:1414::; This is what happens when we forced nmi skip\n; Increase frame counters
P:1416::; reset ball_update_position
P:141A::; Don't skip next NMI request
P:141E::; Restore X, Y and PC from stack
P:1423::; Restore accumulator from stack
P:1424::; Return
P:1425:IRQ:; IRQ handler (empty)
R:0000:ADDR_CHRROM
R:0000:ADDR_ZEROPAGE
R:0000:BALL_ATTR
R:0000:BALL_LEFT
R:0000:BALL_TOP
R:0000:IS_INTRO_SCREEN
R:0000:_SPACE
R:0001:BALL_IS_DEAD
R:0001:BALL_TILE_CHR
R:0001:BUTTON_RIGHT
R:0001:IS_GAME_SCREEN
R:0001:KILL_BALL
R:0001:TILE_IS_SOLID
R:0001:_0
R:0002:BALL_SPEED_HI
R:0002:BUTTON_LEFT
R:0002:IS_WIN_SCREEN
R:0002:NUDGE_BALL_RIGHT
R:0002:_1
R:0003:CHECK_SCREEN_MODE
R:0003:NUDGE_FRAMES
R:0003:SLIDE_WIDTH
R:0003:_2
R:0004:ANIMATION_SPEED
R:0004:BALL_HALF_SIZE
R:0004:BALL_IS_FROZEN
R:0004:BUTTON_DOWN
R:0004:FREEZE_BALL
R:0004:MAX_ANIMATIONS
R:0004:_3
R:0005:_4
R:0006:_5
R:0007:_6
R:0008:BALL_HEIGHT
R:0008:BALL_WIDTH
R:0008:BUTTON_UP
R:0008:_7
R:0009:SLIDE_SIZE
R:0009:_8
R:000A:ANIM_SLIDES
R:000A:_9
R:000B:_A
R:000C:_B
R:000D:_C
R:000E:_D
R:000F:_E
R:0010:BALL_MOVES_DOWN
R:0010:BOUND_LEFT
R:0010:BUTTON_START
R:0010:IS_DEATH_BLOCK
R:0010:MOVE_BALL_DOWN
R:0010:_F
R:0011:_G
R:0012:_H
R:0013:_I
R:0014:_J
R:0015:_K
R:0016:_L
R:0017:_M
R:0018:_N
R:0019:_O
R:001A:_P
R:001B:_Q
R:001C:_R
R:001D:_S
R:001E:_T
R:001F:_U
R:0020:BUTTON_SELECT
R:0020:IS_PAINT_BLOCK
R:0020:_V
R:0021:_W
R:0022:_X
R:0023:_Y
R:0024:_Z
R:0025:_COMMA
R:0026:_DOT
R:0027:_COLON
R:0028:_COPY
R:0030:BALL_SPEED_LO
R:0030:BOUND_TOP
R:0040:BUTTON_B
R:0040:IS_MOVE_BLOCK
R:0040:SPRITE_0_HIT
R:0080:BUTTON_A
R:0080:IS_COLOR_BLOCK
R:0080:LOAD_INTRO_SCREEN
R:0081:LOAD_GAME_SCREEN
R:0082:LOAD_WIN_SCREEN
R:00C8:BOUND_BOTTOM
R:00D0:BALL_TOP_WGA
R:00E8:BOUND_RIGHT
R:00EF:MOVE_BALL_UP
R:00F0:BALL_LEFT_WGA
R:00FB:UNFREEZE_BALL
R:00FD:NUDGE_BALL_LEFT
R:00FE:REVIVE_BALL
R:00FF:LEVEL_END
R:0100:ADDR_SOUNDRAM
R:0200:ADDR_SPRITERAM
R:0300:ADDR_OTHERRAM
R:0400:ADDR_SCREENTILERAM
G:2000:PPU_CTRL
G:2001:PPU_MASK
G:2002:PPU_STATUS
G:2003:OAM_ADDR
G:2004:OAM_DATA
G:2005:PPU_SCROLL
G:2006:PPU_ADDR
G:2007:PPU_DATA
G:4010:APU_CTRL
G:4014:OAM_DMA
G:4015:APU_STATUS
G:4016:JOYPAD_1
G:4017:APU_FC
G:4017:JOYPAD_2
G:8000:ADDR_STARTBANK
G:C000:ADDR_ENDBANK
G:FFFA:ADDR_VECTORS
