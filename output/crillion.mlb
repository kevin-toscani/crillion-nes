P:0000:temp:; Zero page RAM\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/zp_ram.asm\n;\n; List of zero-page RAM variables. Currently only holds a\n; variable to keep track of button presses, but will contain\n; more variables that should be accessed often or easily by\n; the game at any time, like temporary variables used by\n; subroutines or macros, game status flags, and the like.\n;\n;\n; Reserve ten temporary variables for use in subroutines.
P:000A:temp16:; Reserve a two-byte temporary variable for use with 16-bit\n; operations (like addresses)
P:000C:pointer:; Two-byte variable to store a pointer address
P:000E:buttons_prev:; Variable to store button presses
P:000F:buttons_held
P:0010:buttons_pressed
P:0011:buttons_released
P:0012:soft_ppu_mask:; PPU mask buffer variable, used to store the new value of\n; the PPU mask outside NMI
P:0013:skip_nmi:; Variables to skip NMI handling
P:0014:force_skip_nmi
P:0015:frame_counter:; Counters and seeds
P:0016:random_seed
P:0017:ball_xpos_hi:; Game specific variables\n; Ball variables
P:0018:ball_xpos_lo
P:0019:ball_ypos_hi
P:001A:ball_ypos_lo
P:001B:ball_lives: number of lives left
P:001C:ball_score: decimal score, five bytes (0-9)
P:0022:ball_bonus: decimal bonus points, three bytes (0-9)
P:0025:ball_left:; Ball bounding box, relative to the screen
P:0026:ball_center
P:0027:ball_right
P:0028:ball_top
P:0029:ball_middle
P:002A:ball_bottom
P:002B:ball_update_position:; Update-position check
P:002C:ball_flags:; Ball flags\n; #% c c c v . f n a\n;    | | | | | | | +-- ball is dead (0) or alive (1)\n;    | | | | | | +---- ball is being nudged left (0) or right (1)\n;    | | | | | +------ ball is frozen (not moving)\n;    | | | | +-------- (unused for now)\n;    | | | +---------- ball moves up (0) or down (1)\n;    +-+-+------------ ball color (1-6)
P:002D:screen_mode:; Screen mode\n; #% u . . . . . t t\n;    | | | | | | +-+--------- screen type (00 = intro, 01 = game, 10 = win)\n;    | +-+-+-+-+------------- unused\n;    +----------------------- should the screen update
P:002E:startlevel_pointer:; Start level pointer\n; You can start the game at level 1, 5, 9, 13 or 17.\n; This is the pointer that tells you at which level to start.
P:002F:ppu_buffer_update:; PPU buffer variables
P:0030:ppu_buffer_pointer
P:0031:explosion_pointer:; Pointer to keep track of the number of explosions
P:0032:sprite_ram_pointer:; Sprite RAM pointer to keep track of sprites to update
P:0033:nudge_counter:; Nudge counter
P:0034:current_level:; Current level
P:0035:colliding_tile:; Tile type the ball is currently colliding with
P:0036:ppu_buffer:; Other RAM (must be ENUM'd within)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; ram/misc.asm\n;\n; List of additional, non-zeropage RAM variables. Currently\n; empty, but will hold data like the OAM buffer and other,\n; less-often accessed, global variables.\n;\n;\n; Game specific RAM variables\n; miscellaneous (non-zeropage) ram variables go here\n; PPU buffer (3x16 bytes, as a capped max for NMI)
P:0066:explosion_framecounter:; _framecounter, counts from ANIMATION_SPEED to 0 per slide
P:006A:explosion_currentframe:; _currentframe, keeps track which anim frame we're at
P:006E:explosion_attributes:; _attributes, to distinguish between ball and wall explosion
P:0072:explosion_x:; x- and y-coordinate of the explosion
P:0076:explosion_y
P:007A:explosion_active:; active flag to see if animation is/should be shown
P:007E:tile_type:; screen tile type data\n;  #% b m p d ccC s\n;     | | | | ||| +-- block is solid\n;     | | | | ||+---- block color (CHR offset boolean)\n;     | | | | ++----- block color (subpal 0-3)\n;     | | | +-------- death block\n;     | | +---------- paint block\n;     | +------------ move block\n;     +-------------- color block
P:011E:tile_attributes:; attribute table in ram (for easy updating during gameplay)
P:015E:RESET:; Instantly go to the static bank\n; Reset script\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/reset.asm\n;\n; Basic reset script. Disables rendering, clears memory, moves\n; sprites off screen and (re)initializes the game.\n;\n;\n; Ignore IRQ's
P:015F::; Disable decimal mode
P:0160::; Disable APU frame IRQ
P:0165::; Set up the stack
P:0168::; Disable NMI, rendering, DMC and APU IRQ's
P:0175::; Clear the vBlank flag
P:0178::; Wait for vBlank
P:017B::; Clear memory\n; Move sprites off screen
P:0180::; Clear other memory
P:0196::; Clear next in line
P:0199::; Wait for vBlank
P:019C::; Turn on NMI, set foreground $0000, background $1000
P:01A1::; Reset PPU scroll pointer
P:01A9::; Initialize game\n; game initialization goes here\n; Tell game to load the intro screen
P:01AD::; Set number of lives (5)
P:01B1::; Start at level -1 for now, because [START] increments level number
P:01B5:MainGameLoop:; Main game loop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; game/main.asm\n;\n; The main game loop content.\n;\n;\n; Reset sprite pointer every game loop
P:01B9::; Store previous buttons
P:01BD::; Read controller input
P:01C0::; Get buttons released
P:01C8::; Set buttons pressed
P:01D0::; Load screen?
P:01D6::; Get screen type to load
P:01DB::; Get address to load screen type from
P:01E5::; Load screen
P:01EE::; Don't load screen anymore next loop
P:01F4::; CONCEPT SCRIPTS\n; Upon pressing A, an explosion will happen on screen\n; If A button is pressed, initiate explosion
P:01FD::; Get most recent slot for explosion
P:01FF::; If 0, use max pointer value
P:0203::; Decrease pointer by one
P:0206::; Load explosion data into RAM
P:0213::AND #%11110000
P:0219::AND #%11110000
P:022C::; Set up loop
P:022E::; Check if current animation is active. If not, goto next
P:0236::; Check the explosion framecounter
P:023B::; Framecounter is 0\n; Reset to animation speed
P:0240::; Set next animation frame, and check if we're done yet
P:024A::; If we're done, inactivate current explosion, clean\n; up sprite RAM and go to the next one
P:0261::; Load (x,y) position in temp variables
P:026D::; Load attribute in temp variable
P:0272::; Load current frame into Y-register
P:0275::; Load current frame ROM address from table
P:027F::; Save x-register on stack
P:0281::; Load sprites into sprite RAM
P:0285::; Prepare (x,y) offset for loop
P:0287::; Do not draw empty sprites
P:028B::; Add y-position to sprite ram buffer
P:0291::; Get tile number from frame ROM address, and\n; add it to sprite ram buffer
P:0297::; Add attribute data to sprite ram buffer
P:029D::; Add x-position to sprite ram buffer
P:02A3::; Check if all sprites are done
P:02A8::; Update x value
P:02AF::; Update temp for x,y position
P:02B7::; Row is done; reset x-position
P:02BB::; Update y-position
P:02C2::; Reset row counter
P:02CB::; Retrieve x-register from stack
P:02CD::; Check if all animations have been updated
P:02D5::; Check if we're on the game screen
P:02DE::; We're on the game screen\n; Check if position should be updated (ie. has nmi happened yet)
P:02E5::; Move the ball\n; Check if ball goes up or down
P:02EB::; update the low byte
P:02F2::; update the high byte with carry
P:02F8::; Check bottom bound
P:02FE::; Change ball direction to "up"
P:030F::; update the low byte
P:0316::; update the high byte with carry
P:031C::; Check top bound
P:0320::; Change ball direction to "down"
P:032E::; Check if ball is being nudged
P:0332::; Check if left button is held
P:0338::; update the low byte
P:033F::; update the high byte
P:0345::; Check left bound
P:0349::; Set flag to nudge right and set nudge counter
P:0353::; Check if right button is held
P:0359::; update the low byte
P:0360::; update the high byte
P:0366::; Check right bound
P:036C::; Set flag to nudge left and set nudge timer
P:0373::; Check nudge
P:037D::; update the low byte
P:0384::; update the high byte
P:038D::; update the low byte
P:0394::; update the high byte
P:039A::; Don't update position again until next frame
P:039C::; Test collision detection\n; Get ball's x-left, x-center, x-right position
P:03AD::; Get ball's y-top, y-middle, y-bottom position
P:03BE::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:03C4::; Check tile at right position
P:03D1:: no need for left check as ball moves right
P:03D3::; Tile is solid; nudge ball and evaluate tile type
P:03E0::; Check if ball moves right\n; No need to check nudging here as that will never collide with a tile
P:03E6::; Check tile at right position
P:03F5::; Tile is solid; nudge ball and evaluate tile type
P:03FF::; Check if ball moves up
P:0405::; Check tile at top position
P:0412:: no need for bottom check as ball moves up
P:0414::; Tile is solid; move ball down and evaluate tile type
P:0420::; No movement check needed: since ball is not moving up, it must move down\n; Check tile at bottom position
P:042F::; Tile is solid; move ball up and evaluate tile type
P:0438::JMP +doneCheckingCollision\n; Add to sprite buffer
P:0454::; Upon pressing START, (next level) design will be drawn\n; If START button is pressed
P:045A::; Load the next level
P:046A::; Sprite clean-up
P:0477:sub_GetRandomNumber:; Subroutines\n; RNG\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/GetRandomNumber.asm\n;\n; Simple and fast random number generator by White Flame.\n;\n; Set random_seed to an arbitrary number to randomize between\n; gaming sessions, for instance using the frame counter upon\n; pressing START on the intro screen.\n;\n;     ;; IF START PRESSED:\n;     LDA frame_counter\n;     STA random_seed\n;\n; Source:\n; codebase64.org/doku.php?id=base:small_fast_8-bit_prng\n;\n;\n; Force EOR if random_seed is zero
P:047B::; Shift left, and EOR if the high bit is set
P:0485:sub_ReadController:; Read controller input\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/ReadController.asm\n;\n; Subroutine that polls the controller and stores the input\n; buttons in a variable. This version only handles controller\n; 1. Expects "buttons" variable to be declared in RAM.\n;\n;\n; Set strobe bit
P:048A::; Set up ring counter
P:048C::; Clear strobe bit
P:0490::; Loop through button presses
P:0496::; Check if ring counter is done
P:0498::; Return from subroutine
P:0499:sub_WaitForVBlank:; vBlank wait\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; subroutine/WaitForVBlank.asm\n;\n; Subroutine that essentially pauses script execution until\n; vBlank happens.\n;\n;
P:049F:sub_ClearScreen:; Game specific subroutines\n; additional game-specific subroutines go here\n; Subroutine to clear the screen\n; If it's a game screen, add noise\n; Check of game screen or not
P:04AB::; Set start writing address at tile (0,0) - or PPU address $2000
P:04B8::; Set up tile to draw and loop
P:04BC::; Write empty tile or noise (#$00) and add one to PPU address
P:04C1::; Check if we should draw noise next. Noise is drawn if:\n; - Screen mode is game screen\n; - Y between #$06 and #$19 (inclusive)\n; - X between #$02 and #$1D (inclusive)\n; If not a game screen, or Y exceeds row $17, skip further check
P:04C5::; If Y < $6, skip the check
P:04C9::; If X < $1, skip the check
P:04CD::; If X >= $1D, skip the check. If it IS $1D, set temp = 0
P:04D7::; Load a random noise tile (tiles $68-$6F in CHR ROM)
P:04E1::; Check if a row has been done. If not, draw the next
P:04E6::; Go to the next row (if any left)
P:04E9::; If Y is 1A, skip noise tile check until done drawing
P:04F5::; Clear attribute table
P:050A:sub_ColorizeBall:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n;  Subroutine: ColorizeBall\n;\n;  Applies the color set through ball_flags to the ball sprite.\n;\n;\n; Get color from ball_flags
P:0510::; Add new light color of ball to PPU palette
P:0520::; Add new dark color of ball to PPU palette
P:052B:sub_ColorsMatch:; Subroutine to check if ball color matches colliding tile color\n; Save tile color in temp variable
P:0531::; Get ball color
P:0539::; Compare with tile color
P:053C:sub_ConvertXYToTileType:; Subroutine to convert the ball's position to a tile type\n; - Expects temp to be y-position of ball within game area\n; - Expects temp+1 to be x-position of ball within game area\n; - Puts result in accumulator and zp variable\n; - Corrupts X-register
P:0554:sub_DisableRendering:; Force NMI skip, disable rendering
P:0568:sub_EnableRendering:; Enable rendering
P:0582:sub_drawIntroScreenLogoTile
P:0595:sub_EvaluateTileType:; Subroutine to evaluate the colliding tile type and take its\n; corresponding action (move block, kill player, ...)\n; - Expects X-register to be the ADDR_SCREENTILERAM offset\n; - Uses zp variable colliding_tile\n; Check if collided tile is a color block
P:059B::; It's a color block. Check if the colors match
P:05A0::; Colors don't match - return
P:05A1::; Colors match. Destroy color block\n; - Add the tiles that need updating to ppu buffer\n; - Load destruction animation on tile\n; - Write #$00 in tile type ram (makes not-solid)\n; - Update attribute table accordingly through ppu buffer\n; - If there are no color blocks left:\n;   - Freeze ball\n;   - Initiate level-win state\n; (@TODO)
P:05A2::; Check if collided tile is a paint block
P:05A8::; It's a paint block. Update ball color\n; Save x-register
P:05AA::; Get tile color
P:05B4::; Apply tile color to ball
P:05BF::; Restore x-register
P:05C1::; Return
P:05C2::; Check if collided tile is a death block
P:05C8::; It is a death block. Kill player and return (@TODO)\n        LDA ball_flags\n        ORA #%00000101\n        STA ball_flags
P:05C9::; Check if collided tile is a move block
P:05CF::; It is a move block. Check if colors match
P:05D4::; Colors don't match - return
P:05D5::; Colors match.\n; - Check if next tile is a solid\n; - If not, move the tile:\n;   - Add the tiles that need updating to ppu buffer\n;   - Add move tile sprite over the original tile\n;   - Initiate moving the sprite that way for 16px\n;   - Write #$00 in tile type ram (makes not-solid)\n;   - Update attribute table accordingly through ppu buffer\n; - After moving the sprite, in a different routine:\n;   - Add move tile data on the new tile location\n;   - Write the original tile type data on new position in ram\n;   - Destroy sprite\n;   - Update attribute table accordingly through ppu buffer\n; (@TODO)
P:05D6::; Return
P:05D7:sub_InitiateNudge
P:05DE:sub_JumpToPointer
P:05E1:sub_LoadGameScreen:RTS must be handled by the routine (pointer) jumps to\n; Clear the screen
P:05E4::; Clear collision and attribute data
P:05ED::; Get pointer from current level
P:05F9::; Set up the loop
P:05FB::; Load (x,y) of current set of tiles
P:05FD::; Check if level is done; if so, skip the loop
P:0604::; Store (x,y) and number of tiles and tile data in temp variable
P:060B::; Convert (x,y) to PPU address\n; temp+2 = PPU_hi = $20 + _y/4_ + carry from temp+3
P:0615::; temp+3 = PPU_lo = 2*x + $40*(y%4) + $C2
P:062E::; Add carry to temp+2
P:0634::; Convert tile data to loop count and tile type\n; temp+4 = color
P:063A::; If color = 7, this is a wall
P:063E::; temp+7 = first or second set in CHR (add 5 to offset)
P:0646::; temp+5 = tile type
P:0650::; It's a wall! Set CHR offset to 0, and tile type to 4.
P:0658::; X = tile offset
P:065C::; temp+6 = number of tiles
P:0667::; Translate (x,y) to (y,x) for tile RAM
P:0679::; Set up loop
P:067D::; Write PPU address
P:068A::; Write first and second tile
P:0696::; Update PPU address
P:06A6::; Write third and fourth tile
P:06B2::; Push x-register to stack
P:06B4::; Update tile RAM (aka collision table)
P:06C3::; Check if shade 1 should be drawn
P:06CE::; Check if shade 2 should be drawn
P:06F4::; Check if shade 3 should be drawn
P:070B::; Restore x-register from stack
P:070D::; Reset pointer for next tile
P:071A::; Draw next metatile in this loop (if any left)
P:071D::; Is it a row or a column?
P:0721::; It is a column: move pointer down (+$40)
P:072E::; Add 16 to temp (as a tile RAM pointer)
P:0738::; It is a row: move pointer right (+$02)
P:073F::; Add 1 to temp (as a tile RAM pointer)
P:0741::; Next tile in the row/column
P:0744::; Go to the next set of tiles
P:074A::; Level loading is done\n; Top game bound: set PPU_ADDR offset and draw 28 tiles
P:0759::; Bottom game bound: set PPU_ADDR offset and draw 28 tiles
P:0768::; Left & right game bounds\n; Set PPU_ADDR and store in temp variables
P:0776::; Set vertical bound tile and set up loop
P:077A::; Show left tile
P:077D::; Set PPU_ADDR to right bound by adding 29 (tiles) to low byte
P:078C::; Show right tile
P:078F::; Check if we're done yet
P:0792::; Not done yet: add 3 to low byte for next left bound
P:0799::; Apply carry to high byte
P:079F::; Store next PPU_ADDR to draw at
P:07AA::; Draw the corners of the playing field
P:07E6::; Draw the hud labels
P:07FD::; Draw the current score
P:0816::; Draw the level number\n; (with primitive HEX>DEC)
P:0855::; Draw lives (presumes lives to be capped at 9)
P:0865::; Set and draw bonus
P:0888::; Set attribute data to RAM\n; Byte 0-7 of attribute ram should be #%10100000
P:0894::; Byte 8-55 of attribute ram are filled with game subpal data\n; Reset current attribute value
P:0898::; Get first metatile in tile ram based on attribute index\n; metatile = (attr-8)*2 +(16*(attr-8)/8))
P:089C:: attr - 8 (temp1)
P:089E:: * 2
P:089F:: temp = temp1 * 2
P:08A1:: temp1
P:08A3:: rounded down to 8's
P:08A5:: * 2
P:08A7:: + temp1 * 2
P:08A9:: first metatile
P:08AB::; Store first metatile in y-register
P:08AC::; If X MOD 8 == 7, don't apply bottom right metatile
P:08B3::; If X >= $30, don't apply bottom right metatile
P:08B7::; Add metatile1 subpalette to attribute value
P:08BE::; Apply second metatile
P:08BF::; If X MOD 8 == 0, don't apply bottom left metatile
P:08C4::; If X >= $30, don't apply bottom left metatile
P:08C8::; Add metatile2 subpalette to attribute value
P:08DA::; Apply third metatile
P:08DF::; If X MOD 8 == 7, don't apply top right metatile
P:08E6::; If X < $10, don't apply top right metatile
P:08EB::; Add metatile3 subpalette to attribute value
P:08FD::; Apply fourth metatile
P:08FE::; If X MOD 8 == 0, don't apply top left metatile
P:0903::; If X < $10, don't apply top left metatile
P:0908::; Add metatile4 subpalette to attribute value
P:0919::; Check the next attribute, if any left
P:0921::; Stream attribute RAM to PPU
P:093B::; Set initial ball position
P:0959::; Set initial ball color and direction
P:0963::; Return
P:0964:sub_Draw28HorizontalTiles:; Subroutine: draw 28 tiles in a row
P:096D:sub_LoadIntroScreen:; Load intro palette
P:0987::; Put ball in the middle
P:098D::; Clear the screen
P:0990::; Set up intro screen draw loop
P:0992::; Get current byte from intro screen data
P:0995::; If current byte is #$3F, we're done drawing.
P:099C::; If highest bits are %11, draw a plain tile
P:09A3::; If highest bits are %01, set the PPU address\n; If not, draw two logo tiles
P:09AA::; Get bits 0-2 and store in a temp variable
P:09B1::; Get bits 3-5, shift over to get a value from 0-7
P:09B9::; Draw the tile that corresponds with that value
P:09BD::; Do the same for the value stored in temp
P:09C2::; Next byte please
P:09C6::; Just draw the tile value on screen
P:09CC::; Next byte please
P:09D0::; Reset the PPU latch
P:09D3::; Sanitize and write the high byte of the PPU address
P:09DB::; Write the low byte of the PPU address
P:09E2::; PPU has been set up to draw tiles at the correct spot now.\n; Next byte please.
P:09E6::; To color the 1.LEVEL: line green, we need to update two\n; values in the PPU attribute data.
P:09FC:sub_LoadWinScreen
P:09FD:sub_WriteByteToPPUBuffer:; Prevent updating until full 3-byte buffer is filled,\n; so that graphics won't glitch out if NMI happens during\n; updating the buffer
P:0A01::; Check if buffer full; if so, wait a frame and force update
P:0A0C::; Add ppu_addr high byte to buffer
P:0A11::; Add ppu_addr low byte to buffer
P:0A17::; Add ppu_data to buffer
P:0A1D::; Update buffer pointer
P:0A20::; Tell NMI to update next round
P:0A22::; Return
P:0A23:tbl_IntroScreenPalette:; LUTs\n; Intro screen palette
P:0A43:tbl_IntroScreenLogoChr:; Intro: mapping logo index to chr tile
P:0A4B:tbl_IntroScreenData:; Intro screen data\n; Set PPU address $20AC and draw
P:0A55::; Set PPU address $20CF and draw
P:0A59::; Set PPU address $2122 and draw
P:0A75::; Set PPU address $2147 and draw
P:0A8E::; Set PPU address $218B and draw
P:0A9B::; Set PPU address $21E6 and draw
P:0AB0::; Set PPU address $222D and draw
P:0AB8::; Set PPU address $2281
P:0ABA::; Draw the Crillion logo
P:0B19::; End of intro
P:0B1A:explosion_slide0:; test animation table\n; CHR tile-id's per slide of explosion
P:0B23:explosion_slide1
P:0B2C:explosion_slide2
P:0B35:explosion_slide3
P:0B3E:explosion_slide4
P:0B47:explosion_anim_hi:; High and low bytes of animation slides
P:0B51:explosion_anim_lo
P:0B5B:tbl_BallColorDark:; Ball palette color table (CBRYGM)
P:0B61:tbl_BallColorLight
P:0B67:tbl_LoadScreenHi:; Screen mode drawing routine addresses
P:0B6A:tbl_LoadScreenLo
P:0B6D:lvl_layout_01:; Test level data
P:0B88:lvl_layout_02
P:0BBD:lvl_layout_03
P:0BF0:lvl_layout_04
P:0C61:lvl_layout_05
P:0C9C:lvl_layout_06
P:0D25:lvl_layout_07
P:0D66:lvl_layout_08
P:0D9D:lvl_layout_09
P:0DE0:lvl_layout_10
P:0E0F:lvl_layout_11
P:0E62:lvl_layout_12
P:0E8D:lvl_layout_13
P:0EE0:lvl_layout_14
P:0F57:lvl_layout_15
P:0F88:lvl_layout_16
P:0FDD:lvl_layout_17
P:1044:lvl_layout_18
P:1099:lvl_layout_19
P:10D8:lvl_layout_20
P:1123:lvl_layout_21
P:1160:lvl_layout_22
P:118D:lvl_layout_23
P:11D8:lvl_layout_24
P:121D:lvl_layout_25
P:124C:tbl_lvl_layout_hi:; Level layout address pointers
P:1265:tbl_lvl_layout_lo
P:127E:tbl_lvl_ball_startpos:; Ball start position (#$YX)
P:1297:tbl_lvl_ball_init:; Ball start direction, color and tile score\n; #% ccc v tttt\n;    ||| | ++++-- tile score\n;    ||| +------- vertical direction, up (0) or down\n;    +++--------- color (CBRYGM)
P:12B0:tbl_Times64:; Helper table to multiply values by 64
P:12B4:tbl_GametileTopLeft:; Metatile ID to CHR data mapper
P:12BE:tbl_GametileTopRight
P:12C8:tbl_GametileBottomLeft
P:12D2:tbl_GametileBottomRight
P:12DC:tbl_GameTileRamByte:; Metatile ID to RAM byte data mapper
P:12E1:tbl_HudText:; HUD text data
P:12FD:NMI:; NMI handler\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; include/nmi.asm\n;\n; Non-maskable interrupt script. This script is being executed\n; when vBlank hits.\n;\n;\n; Preserve accumulator through stack
P:12FE::; Should NMI be skipped?
P:1305::; When in NMI, skip additional NMI requests
P:1309::; Preserve X, Y, and PC through stack
P:130E::; Check forced NMI skip
P:1315::; Update PPU mask\nLDA #$00\nSTA PPU_CTRL
P:131A::; Additional PPU updates go here\n; Check if ppu_buffer needs updating
P:1321::; Reset ppu control register and mask
P:1329::; Set up loop\n; Reset hi/lo latch
P:132C::; Write ppu_buffer hi and lo addresss to PPU_ADDR
P:1339::; Write ppu_buffer data to PPU_ADDR
P:1340::; Check if updating is done (eg. X is at pointer)
P:1348::; Reset ppu buffer update and pointer
P:134E::; Reset scrolling position
P:1354::; Restore ppu control register and mask
P:1360::; Continue other NMI stuff\n; Reset sprite RAM, draw sprites
P:1381::; This is what happens when we forced nmi skip\n; Increase frame counters
P:1383::; reset ball_update_position
P:1387::; Don't skip next NMI request
P:138B::; Restore X, Y and PC from stack
P:1390::; Restore accumulator from stack
P:1391::; Return
P:1392:IRQ:; IRQ handler (empty)
R:0000:ADDR_CHRROM
R:0000:ADDR_ZEROPAGE
R:0000:BALL_ATTR
R:0000:BALL_LEFT
R:0000:BALL_TOP
R:0000:IS_INTRO_SCREEN
R:0000:_SPACE
R:0001:BALL_IS_DEAD
R:0001:BALL_TILE_CHR
R:0001:BUTTON_RIGHT
R:0001:IS_GAME_SCREEN
R:0001:KILL_BALL
R:0001:TILE_IS_SOLID
R:0001:_0
R:0002:BALL_SPEED_HI
R:0002:BUTTON_LEFT
R:0002:IS_WIN_SCREEN
R:0002:NUDGE_BALL_RIGHT
R:0002:_1
R:0003:CHECK_SCREEN_MODE
R:0003:NUDGE_FRAMES
R:0003:SLIDE_WIDTH
R:0003:_2
R:0004:ANIMATION_SPEED
R:0004:BALL_HALF_SIZE
R:0004:BALL_IS_FROZEN
R:0004:BUTTON_DOWN
R:0004:FREEZE_BALL
R:0004:MAX_ANIMATIONS
R:0004:_3
R:0005:_4
R:0006:_5
R:0007:_6
R:0008:BALL_HEIGHT
R:0008:BALL_WIDTH
R:0008:BUTTON_UP
R:0008:_7
R:0009:SLIDE_SIZE
R:0009:_8
R:000A:ANIM_SLIDES
R:000A:_9
R:000B:_A
R:000C:_B
R:000D:_C
R:000E:_D
R:000F:_E
R:0010:BALL_MOVES_DOWN
R:0010:BOUND_LEFT
R:0010:BUTTON_START
R:0010:IS_DEATH_BLOCK
R:0010:MOVE_BALL_DOWN
R:0010:_F
R:0011:_G
R:0012:_H
R:0013:_I
R:0014:_J
R:0015:_K
R:0016:_L
R:0017:_M
R:0018:_N
R:0019:_O
R:001A:_P
R:001B:_Q
R:001C:_R
R:001D:_S
R:001E:_T
R:001F:_U
R:0020:BUTTON_SELECT
R:0020:IS_PAINT_BLOCK
R:0020:_V
R:0021:_W
R:0022:_X
R:0023:_Y
R:0024:_Z
R:0025:_COMMA
R:0026:_DOT
R:0027:_COLON
R:0028:_COPY
R:0030:BALL_SPEED_LO
R:0030:BOUND_TOP
R:0040:BUTTON_B
R:0040:IS_MOVE_BLOCK
R:0080:BUTTON_A
R:0080:IS_COLOR_BLOCK
R:0080:LOAD_INTRO_SCREEN
R:0081:LOAD_GAME_SCREEN
R:0082:LOAD_WIN_SCREEN
R:00C8:BOUND_BOTTOM
R:00D0:BALL_TOP_WGA
R:00E8:BOUND_RIGHT
R:00EF:MOVE_BALL_UP
R:00F0:BALL_LEFT_WGA
R:00FB:UNFREEZE_BALL
R:00FD:NUDGE_BALL_LEFT
R:00FE:REVIVE_BALL
R:00FF:LEVEL_END
R:0100:ADDR_SOUNDRAM
R:0200:ADDR_SPRITERAM
R:0300:ADDR_OTHERRAM
R:0400:ADDR_SCREENTILERAM
G:2000:PPU_CTRL
G:2001:PPU_MASK
G:2002:PPU_STATUS
G:2003:OAM_ADDR
G:2004:OAM_DATA
G:2005:PPU_SCROLL
G:2006:PPU_ADDR
G:2007:PPU_DATA
G:4010:APU_CTRL
G:4014:OAM_DMA
G:4015:APU_STATUS
G:4016:JOYPAD_1
G:4017:APU_FC
G:4017:JOYPAD_2
G:8000:ADDR_STARTBANK
G:C000:ADDR_ENDBANK
G:FFFA:ADDR_VECTORS
